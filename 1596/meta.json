{"ID":1596,"Author":{"Name":"Overbryd","ID":0,"FullName":"","Gravatar":"5bad5652a2128c54460b38ac8f4ed8ce"},"Title":"Stateful Application Server","Description":"\u003cdiv class=\"content\"\u003e\u003cp\u003eThe talk is about a stateful application server built on top of JRuby/JVM. We at Wooga have built and evaluated such an application server, and now I want to share the learnings and obstacles that came up during development.\u003c/p\u003e\n\n\u003cp\u003eScaling up: We aim to fully utilize our available hardware. One box has 32 Cores and more than 32GB RAM available. How to saturate such beasts? Well, since JRuby supports real Threads we can share state (uh oh!) and saturate cores.\u003c/p\u003e\n\n\u003cp\u003eScaling out: What are the options for scaling a stateful application server? How to shard state across many servers safely?\u003c/p\u003e\n\n\u003cp\u003eI aim for a talk that gives useful tips and shows code. Basically a ratio between 30% background information, 70% showcasing.\u003c/p\u003e\n\n\u003cp\u003eThe talk will cover the following topics:\u003c/p\u003e\n\n\u003cp\u003eSafely sharing state in a concurrent environment using JRuby \u003cbr/\u003e\nUsing Java concurrency utils in JRuby \u003cbr/\u003e\nPractical tips for planning out deployments \u003cbr/\u003e\nPractical tips for calculating static shards by performance\u003c/p\u003e\n\u003c/div\u003e","Time":"2012-11-20T16:32:09Z","Tags":["OS X","bash","xterm-256color"]}